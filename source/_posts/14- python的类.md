---
title: python的类
tags: 
	- python
	- 面向对象
categories: "python学习"
date: 2018-10-11 20:08:00
updated: 2018-10-17 19:53:00
---

### 0 坑的实例
``` python {.line-numbers}
class A:
	a = []
	def foo(self,a):
	    pass
```

``` python {.line-numbers}
class A:	
	def foo(self,a):
	    self.a = []
	    pass
```
**这俩啥区别？**
做该题目时遇到了坑[Binary Tree Path.](https://leetcode.com/problems/binary-tree-paths/description/)

>注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。
有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：

### 1 python的对象删除
``` python {.line-numbers}
a = [1,2,3]
b = a
b.pop()
print(a)
# [1,2]

#id() 函数用于获取对象的内存地址。
id(a)
#2298578344904
id(b)
#2298578344904

del(b)
id(a)
##2298578344904
id(b)
#name 'b' is not defined
```
>del删除的是变量，而不是数据，解除了变量和数据的联系。

以上现象说明了：
- 1.'='赋值的两个对象具有相同的内存地址。
- 2.修改其中一个 另外一个值也会受到影响.(类似于C++中的指针)
- 3.del其中一个 另外一个却不受影响.(类似于C++中引用
>看网上的总结：
>- 1.首先介绍python的对象引用
  >>- a. python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是**传对象引用**的方式。实际上，这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值——相当于通过**传引用**来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象——相当于通过**传值**来传递对象。
   >>- b. 当人们复制列表或字典时，就复制了对象列表的引用同，如果改变引用的值，则修改了原始的参数。
   >>  - c . 为了简化内存管理，Python通过引用计数机制实现自动垃圾回收功能，Python中的每个对象都有一个引用计数，用来计数该对象在不同场所分别被引用了多少次。每当引用一次Python对象，相应的引用计数就增1，每当消毁一次Python对象，则相应的引用就减1，只有当引用计数为零时，才真正从内存中删除Python对象.
>- 2. del函数。删除引用，而不是删除对象。对象由自动垃圾回收机制删除。解释了删除掉a之后 b还有值的缘故。
``` python {.line-numbers}
a = 2
b = a
b = 3
print(a)
#2
```

